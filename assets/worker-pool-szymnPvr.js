class n{constructor(e,s=navigator.hardwareConcurrency||4){this.workerFactory=e,this.maxWorkers=Math.min(s,8),this.workers=[],this.availableWorkers=[],this.queue=[],this.activeJobs=0,this.statusCallbacks=new Set,this.messageId=0,this.pendingMessages=new Map,console.log(`🔧 初始化原生 Worker Pool: ${this.maxWorkers} workers`),this.initializeWorkers()}async initializeWorkers(){for(let e=0;e<this.maxWorkers;e++)try{const s=this.workerFactory();s.onmessage=t=>this.handleWorkerMessage(e,t),s.onerror=t=>this.handleWorkerError(e,t),this.workers.push({worker:s,busy:!1,index:e,lastUsed:Date.now()}),this.availableWorkers.push(e),console.log(`✅ Worker ${e} 初始化成功`)}catch(s){console.error(`❌ Worker ${e} 初始化失敗:`,s)}console.log(`🎯 Worker Pool 初始化完成: ${this.workers.length}/${this.maxWorkers}`),this.notifyStatusChange()}handleWorkerMessage(e,s){const{messageId:t,result:o,error:r}=s.data;if(this.pendingMessages.has(t)){const{resolve:a,reject:i}=this.pendingMessages.get(t);this.pendingMessages.delete(t),r?i(new Error(r)):a(o),this.releaseWorker(e)}}handleWorkerError(e,s){console.error(`❌ Worker ${e} 發生錯誤:`,s),this.releaseWorker(e),this.recreateWorker(e)}async recreateWorker(e){try{this.workers[e].worker.terminate();const t=this.workerFactory();t.onmessage=o=>this.handleWorkerMessage(e,o),t.onerror=o=>this.handleWorkerError(e,o),this.workers[e]={worker:t,busy:!1,index:e,lastUsed:Date.now()},console.log(`🔄 Worker ${e} 重新創建成功`)}catch(s){console.error(`❌ Worker ${e} 重新創建失敗:`,s)}}async executeTask(e,s={},t=3e4){return new Promise((o,r)=>{const a={method:e,params:s,resolve:o,reject:r,timeout:t,createdAt:Date.now()};this.availableWorkers.length>0?this.processTask(a):(this.queue.push(a),console.log(`⏳ 任務加入佇列: ${this.queue.length} pending`))})}async processTask(e){const s=this.availableWorkers.shift(),t=this.workers[s];if(!t||t.busy){this.queue.unshift(e);return}t.busy=!0,t.lastUsed=Date.now(),this.activeJobs++,this.notifyStatusChange();const o=++this.messageId,r=setTimeout(()=>{this.pendingMessages.has(o)&&(this.pendingMessages.delete(o),e.reject(new Error(`Worker 任務超時 (${e.timeout}ms)`)),this.releaseWorker(s))},e.timeout);this.pendingMessages.set(o,{resolve:a=>{clearTimeout(r),e.resolve(a)},reject:a=>{clearTimeout(r),e.reject(a)}});try{t.worker.postMessage({messageId:o,method:e.method,params:e.params})}catch(a){this.pendingMessages.delete(o),clearTimeout(r),e.reject(a),this.releaseWorker(s)}}releaseWorker(e){const s=this.workers[e];if(s&&s.busy&&(s.busy=!1,this.availableWorkers.push(e),this.activeJobs--,this.notifyStatusChange(),this.queue.length>0)){const t=this.queue.shift();setTimeout(()=>this.processTask(t),0)}}onStatusChange(e){return this.statusCallbacks.add(e),e(this.getStatus()),()=>this.statusCallbacks.delete(e)}notifyStatusChange(){const e=this.getStatus();for(const s of this.statusCallbacks)try{s(e)}catch(t){console.error("狀態回調執行錯誤:",t)}}getStatus(){return{totalWorkers:this.workers.length,availableWorkers:this.availableWorkers.length,busyWorkers:this.workers.filter(e=>e.busy).length,queuedTasks:this.queue.length,activeJobs:this.activeJobs,pendingMessages:this.pendingMessages.size}}async terminate(){console.log("🔴 終止 Worker Pool...");for(const[e,{reject:s}]of this.pendingMessages)s(new Error("Worker Pool 正在終止"));this.pendingMessages.clear();for(const e of this.workers)try{e.worker.terminate()}catch(s){console.error("終止 Worker 時發生錯誤:",s)}this.workers=[],this.availableWorkers=[],this.queue=[],this.activeJobs=0,this.statusCallbacks.clear(),console.log("✅ Worker Pool 已終止")}}class h{constructor(){this.pools=new Map,this.globalStatusCallbacks=new Set}getPool(e,s,t){if(!this.pools.has(e)){const o=new n(s,t);this.pools.set(e,o),o.onStatusChange(r=>{this.notifyGlobalStatusChange(e,r)}),console.log(`📦 創建新的 Worker Pool: ${e}`)}return this.pools.get(e)}onAllStatusChange(e){this.globalStatusCallbacks.add(e);const s={};for(const[t,o]of this.pools)s[t]=o.getStatus();return e(null,null,s),()=>this.globalStatusCallbacks.delete(e)}notifyGlobalStatusChange(e,s){const t={};for(const[o,r]of this.pools)t[o]=r.getStatus();for(const o of this.globalStatusCallbacks)try{o(e,s,t)}catch(r){console.error("全局狀態回調執行錯誤:",r)}}async terminateAll(){const e=[];for(const[s,t]of this.pools)console.log(`🔴 終止 Worker Pool: ${s}`),e.push(t.terminate());await Promise.all(e),this.pools.clear(),this.globalStatusCallbacks.clear(),console.log("✅ 所有 Worker Pools 已終止")}getAllStatus(){const e={};for(const[s,t]of this.pools)e[s]=t.getStatus();return e}}const c=new h;export{c as w};
